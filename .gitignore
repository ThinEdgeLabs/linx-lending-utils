# Node.js
**/node_modules/
**/package-lock.json
**/yarn.lock
**/pnpm-lock.yaml

# Environment variables
**/.env
**/*.env.*
**/.env.example # Keep this if you have an example environment file

# Logs
**/logs
**/*.log
**/npm-debug.log*
**/lerna-debug.log*
**/yarn-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
**/pids
**/*.pid
**/*.seed
**/*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
**/lib-cov

# Coverage data used by tools like istanbul
coverage
.nyc_output

# Grunt build output
.grunt

# Bower dependency directory (if used)
**/bower_components/

# Frontend build output (if applicable)
**/dist/
**/build/
**/public/build/

# IDE and editor specific files
**/.DS_Store
**/.idea/
**/.vscode/
**/*.suo
**/*.ntvs*
**/*.njsproj
**/*.sln

# Optional npm cache directory
**/.npm

# Optional eslint cache
**/.eslintcache

# Optional REPL history
**/.node_repl_history

# Output of 'npm pack'
**/*.tgz

# Compiled files
**/*.js.map

# macOS files
.AppleDouble
.LSOverride

# Temporary files often created by operating systems and applications
**/._*
**/*.swp
**/*.swo
**/*.swn
**/*.un~

**/artifacts/

 // Implement the borrowRate function from IInterestRate interface
    pub fn borrowRate(marketParams: MarketParams, marketState: MarketState) -> U256 {
        assert!(callerAddress!() == linx, ErrorCodes.NotAuthorized)
        
        // We'll use a simpler implementation with the existing interface
        let id = #deadbeef // Using a fixed ID for demonstration
        let (avgRate, endRateAtTarget) = calculateSimpleBorrowRate(id, marketParams, marketState)
        
        // Update the rate at target
        rateAtTarget[id] = endRateAtTarget
        
        // Emit event
        emit BorrowRateUpdate(id, avgRate, toU256(endRateAtTarget))
        
        return avgRate
    }
    
    // Extended borrowRate function that works with the extended structures
    // This is not part of the public interface but shows how to implement with complete params
    fn extendedBorrowRate(marketParams: ExtendedMarketParams, marketState: ExtendedMarket) -> U256 {
        let id = marketId(marketParams)
        let (avgRate, endRateAtTarget) = calculateExtendedBorrowRate(id, marketState)
        
        // Update the rate at target
        rateAtTarget[id] = endRateAtTarget
        
        // Would emit event here
        
        return avgRate
    }
    
    // View function to get borrow rate without updating state
    pub fn borrowRateView(marketParams: MarketParams, marketState: MarketState) -> U256 {
        let id = #deadbeef // Same fixed ID for demonstration
        let (avgRate, _) = calculateSimpleBorrowRate(id, marketParams, marketState)
        return avgRate
    }
    
    // Implementation of getRate from IDynamicRate
    pub fn getRate() -> U256 {
        let dummyId = #00
        let rate = rateAtTarget[dummyId]
        if (rate == 0i) {
            return toU256(INITIAL_RATE_AT_TARGET)
        }
        return toU256(rate)
    }
    
    // Internal function to calculate the borrow rate with existing structs
    fn calculateSimpleBorrowRate(id: ByteVec, marketParams: MarketParams, marketState: MarketState) -> (U256, I256) {
        // Simple utilization calculation based on limited data
        let utilization = calculateSimpleUtilization(marketState)
        
        return calculateRates(id, utilization, marketState.totalLendingOffers)
    }
    
    // Internal function to calculate the borrow rate with extended structs
    fn calculateExtendedBorrowRate(id: ByteVec, marketState: ExtendedMarket) -> (U256, I256) {
        // Calculate utilization using proper formula
        let utilizationU256 = utilizationRate(marketState)
        let utilization = toI256(utilizationU256)
        
        return calculateRates(id, utilization, marketState.lastUpdate)
    }
        
    // Internal function to calculate borrow rate
    fn calculateBorrowRate(id: ByteVec, market: MarketState) -> (U256, U256) {
        // Calculate utilization
        let utilization = if (market.totalSupplyAssets > 0) {
            wadDiv(market.totalBorrowAssets, market.totalSupplyAssets)
        } else {
            0
        }
        
        // Calculate error normalized by distance to target
        let errNormFactor = if (utilization > TARGET_UTILIZATION) {
            WAD - TARGET_UTILIZATION
        } else {
            TARGET_UTILIZATION
        }
        
        let err = if (errNormFactor > 0) {
            wadDiv(utilization - TARGET_UTILIZATION, errNormFactor)
        } else {
            0
        }
        
        let startRateAtTarget = rateAtTarget[id]
        
        let avgRateAtTarget: U256
        let endRateAtTarget: U256
        
        if (startRateAtTarget == 0) {
            // First interaction
            avgRateAtTarget = INITIAL_RATE_AT_TARGET
            endRateAtTarget = INITIAL_RATE_AT_TARGET
        } else {
            // Calculate adjustment
            let speed = wadMul(ADJUSTMENT_SPEED, err)
            let elapsed = blockTimeStamp!() - market.lastUpdate
            let linearAdaptation = speed * elapsed
            
            if (linearAdaptation == 0) {
                avgRateAtTarget = startRateAtTarget
                endRateAtTarget = startRateAtTarget
            } else {
                endRateAtTarget = newRateAtTarget(startRateAtTarget, linearAdaptation)
                let midRateAtTarget = newRateAtTarget(startRateAtTarget, linearAdaptation / 2)
                avgRateAtTarget = (startRateAtTarget + endRateAtTarget + 2 * midRateAtTarget) / 4
            }
        }
        
        // Apply the rate curve
        return (applyCurve(avgRateAtTarget, err), endRateAtTarget)
    }
    // Common rate calculation logic used by both implementations
    fn calculateRates(id: ByteVec, utilization: I256, lastUpdateValue: U256) -> (U256, I256) {
        // Calculate error from target
        let errNormFactor = if (utilization > TARGET_UTILIZATION) {
            WAD - TARGET_UTILIZATION
        } else {
            TARGET_UTILIZATION
        }
        
        let err = divToZero(utilization - TARGET_UTILIZATION, errNormFactor)
        
        // Get the current rate at target
        let startRateAtTarget = rateAtTarget[id]
        
        let avgRateAtTarget = 0i
        let endRateAtTarget = 0i
        
        if (startRateAtTarget == 0i) {
            // First interaction
            avgRateAtTarget = INITIAL_RATE_AT_TARGET
            endRateAtTarget = INITIAL_RATE_AT_TARGET
        } else {
            // Calculate the adaptation
            let speed = mulToZero(ADJUSTMENT_SPEED, err)
            // Use the lastUpdate field for time calculation
            let elapsed = blockTimeStamp!() - lastUpdateValue.toLong()
            let linearAdaptation = speed * elapsed
            
            if (linearAdaptation == 0i) {
                // No change
                avgRateAtTarget = startRateAtTarget
                endRateAtTarget = startRateAtTarget
            } else {
                // Calculate new rates with the adaptive curve
                endRateAtTarget = newRateAtTarget(startRateAtTarget, linearAdaptation)
                let midRateAtTarget = newRateAtTarget(startRateAtTarget, linearAdaptation / 2i)
                avgRateAtTarget = (startRateAtTarget + endRateAtTarget + 2i * midRateAtTarget) / 4i
            }
        }
        
        // Apply the curve function and return
        return (toU256(curve(avgRateAtTarget, err)), endRateAtTarget)
    }
    
    // Calculate simple utilization from basic market state
    fn calculateSimpleUtilization(marketState: MarketState) -> I256 {
        // In the simplified model, we assume the totalLendingOffers represents a utilization percentage
        // We divide by 100 to get a value between 0 and 1 (scaled by WAD)
        return toI256(marketState.totalLendingOffers) / 100i
    }
    
    // Curve function that calculates the rate based on rate at target and error
    fn curve(rateAtTarget: I256, err: I256) -> I256 {
        let coeff = if (err < 0i) {
            WAD - divToZero(WAD, CURVE_STEEPNESS)
        } else {
            CURVE_STEEPNESS - WAD
        }
        
        return mulToZero(mulToZero(coeff, err) + WAD, rateAtTarget)
    }
    
    // Calculate new rate at target with bounds
    fn newRateAtTarget(startRateAtTarget: I256, linearAdaptation: I256) -> I256 {
        let expResult = wExp(linearAdaptation)
        let result = mulToZero(startRateAtTarget, expResult)
        
        // Apply bounds
        if (result < MIN_RATE_AT_TARGET) {
            return MIN_RATE_AT_TARGET
        }
        if (result > MAX_RATE_AT_TARGET) {
            return MAX_RATE_AT_TARGET
        }
        return result
    }
    
    // Utility function for exponentiation (simplified exp function)
    fn wExp(x: I256) -> I256 {
        // Simple implementation for exp function
        // For a full implementation, would need Taylor series
        if (x <= -41e18) {
            return 0i
        }
        if (x >= 50e18) {
            return 5184705528587072464148529318587763064i // Approx exp(50)
        }
        
        // Simplified exp calculation
        // This is an approximation - in production would need more precision
        return WAD + x + mulToZero(x, x) / 2i
    }
    
    // Division function that rounds to zero (like Solidity)
    fn divToZero(a: I256, b: I256) -> I256 {
        if (a == 0i || b == 0i) {
            return 0i
        }
        if ((a < 0i && b > 0i) || (a > 0i && b < 0i)) {
            return (a * WAD) / b - 1i
        }
        return (a * WAD) / b
    }
    
    // Multiplication function that rounds to zero
    fn mulToZero(a: I256, b: I256) -> I256 {
        let result = (a * b) / WAD
        if ((a < 0i && b > 0i) || (a > 0i && b < 0i)) {
            if ((a * b) % WAD != 0i) {
                result -= 1i
            }
        }
        return result
    }
    
    // Utility to convert I256 to U256 (for non-negative values)
    fn toU256(value: I256) -> U256 {
        if (value < 0i) {
            return 0
        }
        return value.toU256()
    }
    
    // Utility to convert U256 to I256
    fn toI256(value: U256) -> I256 {
        return value.toI256()
    }
    
    // Allow admin to update linx address
    @using(updateFields = true, checkExternalCaller = false)
    pub fn updateLinx(newLinx: Address) -> () {
        assert!(callerAddress!() == admin, ErrorCodes.NotAuthorized)
        assert!(newLinx != zeroAddress!(), ErrorCodes.ZeroAddress)
        linx = newLinx
    }
    
    // Allow admin to transfer admin rights
    @using(updateFields = true, checkExternalCaller = false)
    pub fn transferAdmin(newAdmin: Address) -> () {
        assert!(callerAddress!() == admin, ErrorCodes.NotAuthorized)
        assert!(newAdmin != zeroAddress!(), ErrorCodes.ZeroAddress)
        admin = newAdmin
    }

    fn utilizationRate(market: ExtendedMarket) -> U256 {
        if (market.totalSupplyAssets == 0) {
            return 0
        }
        return (market.totalBorrowAssets * 1e18) / market.totalSupplyAssets
    }
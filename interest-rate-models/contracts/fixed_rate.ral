// Fixed Rate Interest Rate Model
// Implements a constant borrow rate that doesn't change with market conditions
Contract FixedRate(
    admin: Address,
    mut rate: U256,
    mut rateUpdated: Bool
) extends Constants() implements IFixedRate {
    // Events for rate changes
    event RateSet(setter: Address, oldRate: U256, newRate: U256)
    
    pub fn borrowRate(marketParams: MarketParams, marketState: MarketState) -> U256 {
        // Fixed rate model, so we don't need to use marketParams and marketState
        let _ = marketParams
        let _ = marketState
        return rate
    }
    
    pub fn getRate() -> U256 {
        return rate
    }
    
    @using(updateFields = true, checkExternalCaller = false)
    pub fn setBorrowRate(newBorrowRate: U256) -> () {
        assert!(callerAddress!() == admin, ErrorCodes.NotAuthorized)
        assert!(!rateUpdated, ErrorCodes.RateAlreadySet)
        assert!(newBorrowRate <= MAX_BORROW_RATE, ErrorCodes.InvalidRate)
        
        // Update the rate updated flag
        rateUpdated = true
        
        // Update the rate with the new value
        rate = newBorrowRate
        
        // Emit event for tracking
        emit RateSet(callerAddress!(), rate, newBorrowRate)
    }
} 